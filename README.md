# Java-Pattern 设计模式
设计模式遵循的六大原则：

1. 单一职责（一个类和方法只做一件事）
2. 里氏替换（多态，子类可扩展）
3. 依赖倒置（细节依赖抽象，下层依赖上层）
4. 接口隔离（建立单一接口）
5. 迪米特原则（最少知道，降低耦合）
6. 开闭原则（抽象架构，扩展实现）


## 1. 创建者模式

提供创建对象的机制，提升已有代码的灵活性和可复用性。创建模式有5类

1. 工厂方法
2. 抽象工厂
3. 建造者
4. 原型
5. 单例

### 1.1 工厂方法模式

创建型设计模式，实质是在父类中提供一个创建对象实例的方法，允许子类决定实例对象的类型

主要意图是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类型，工厂方法模式使其创建过程延迟到子类进行

提供代码结构扩展性，屏蔽一个功能类中的具体实现逻辑。让外部可更加简单的知道调用即可。

##### 优点
 1. 避免创建者与具体产品逻辑耦合、满足单一职责。每个业务逻辑实现都在所属自己的类中完成；
 2. 满足开闭原则，无需更改使用调用方就可以在程序中引入新的产品类型；

##### 缺点
 1. 假如实现的类型比较多，那么实现的子类会急速扩张，导致大量的子类接口产生。因此也需要其他模式进行优化。


### 1.2 抽象工厂

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

抽象工厂模式和工厂方法模式虽然主要目的是为了解决 ***接口选择***问题，但是实现上，抽象工厂是一个中心工厂，***创建其他工厂模式***。

场景：
大部分兼容场景譬如 ： 
* 不同系统之间的换行符号  Unix系统⾥，每⾏结尾只有 <换⾏>，即 \n; Windows系统⾥⾯，每⾏结尾是 <换⾏><回⻋>，即 \n\r; Mac系统⾥，每⾏结尾是 <回⻋>
* IDEA 开发⼯具的差异展示(Win\Mac)




### 1.3 建造者模式

将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示

### 1.4 原型模式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

### 1.5 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

## 2. 结构型模式



### 2.1 结构型模式

### 2.2 结构型模式

## 3. 行为模式